

# 读取不一致

## 概述

    并发事务情况下，会出现读取不一致的问题
    例如 脏读、不可重复读、幻读的问题，

## 类型

脏读

    脏读（dirty read）
    事务A读到了事务B未提交的数据
    假如B回退，则事务A读取的是无效的数据。

不可重复读

    不可重复读（non-repeatable read）
    在同一事物内，对于同一行数据，先后两次读取的结果不一样

幻读

    幻读（phantom read）
    在同一事物内，对于同一个查询，先后两次读取的结果不一样

## 影响

# 隔离级别

## 概述

    隔离级别用于标识能解决读取不一致的问题的级别
    标准的事务隔离级别包括：读未提交、读提交、可重复读和串行化

## 类型

读未提交

    读未提交（read uncommitted）
    不能解决任何问题
    
读提交

    读提交（read committed）
    可以解决脏读问题
    
可重复读

    可重复读（repeatable read）
    可以解决脏读、不可重复度的问题

串行化

    串行化（serializable ）、
    可以脏读、不可重复读、幻读的问题


# 选择



性能

    隔离级别越高，它所带来的资源消耗也就越大(锁)，因此它的并发性能越低
    mysql的next key lock 


    Oracle数据库的默认隔离级别其实就是“读提交”，
    innoDB默认的隔离级别是RR，全功能的

解决
 
    分析的问题都是在可重复读隔离级别下的，间隙锁是在可重复读隔离级别下才会生效的。
    所以，你如果把隔离级别设置为读提交的话，就没有间隙锁了。
    但同时，你要解决可能出现的数据和日志不一致问题，需要把binlog格式设置为row。这，也是现在不少公司使用的配置组合。
    务不需要可重复读的保证，这样考虑到读提交下操作数据的锁范围更小（没有间隙锁），这个选择是合理的
    
    然后，在备份期间，备份线程用的是可重复读，而业务线程用的是读提交。同时存在两种事务隔离级别，会不会有问题
    
   
