# 概述

    隔离级别
    用于标识数据库能解决并发读写的问题的级别


# 处理并发问题

目的

    数据库锁设计的初衷是处理并发问题。


读-读情况

    即并发事务相继读取相同的记录。
    读取操作本身不会对记录有一毛钱影响

写-写情况：
    
    即并发事务相继对相同的记录做出改动。
    在这种情况下会发生脏写的问题，
    多个未提交事务相继对一条记录做改动时，需要让它们排队执行，通过锁

读-写或写-读情况：

    也就是一个事务进行读取操作，另一个进行改动操作。

    我们前边说过，这种情况下可能发生脏读、不可重复读、幻读的问题。
    
    方案一：读操作利用多版本并发控制（MVCC），写操作进行加锁。
         采用MVCC方式的话，读-写操作彼此并不冲突，性能更高，采用加锁方式的话，读-写操作彼此需要排队执行，影响性能
    
    方案二：读、写操作都采用加锁的方式。
         
    
    
    
# 并发读写问题

## 概述

    并发事务时，
    写写、读写可能可能出现的读写问题 
    按照严重性来排序：
    脏写 > 脏读 > 不可重复读 > 幻读


## 类型

脏写

    脏写（Dirty Write）
    一个事务修改了另一个未提交事务修改过的数据

脏读

    脏读（dirty read）
    事务A读到了事务B未提交的数据
    假如B回退，则事务A读取的是无效的数据。

不可重复读

    不可重复读（non-repeatable read）
    在同一事物内，对于同一行数据，先后两次读取的结果不一样

幻读

    幻读（phantom read）
    在同一事物内，对于同一个查询，先后两次读取的 行 不一样



# 隔离级别

## 概述

    用于标识数据库能解决并发读写的问题的级别
    从低到高排序
    读未提交<读提交<可重复读<串行化

## 详情

读未提交

    读未提交（read uncommitted）
    解决脏写
    
读提交

    读提交（read committed）
    解决脏写 脏读
    
可重复读

    可重复读（repeatable read）
    解决脏写 脏读 不可重复度

串行化

    串行化（serializable ）、
    解决脏写 脏读 不可重复度 幻读


# 选择



性能

    隔离级别越高，它所带来的资源消耗也就越大(锁)，因此它的并发性能越低
    mysql的next key lock 


    Oracle数据库的默认隔离级别其实就是“读提交”，
    innoDB默认的隔离级别是RR，全功能的

解决
 
    分析的问题都是在可重复读隔离级别下的，间隙锁是在可重复读隔离级别下才会生效的。
    所以，你如果把隔离级别设置为读提交的话，就没有间隙锁了。
    但同时，你要解决可能出现的数据和日志不一致问题，需要把binlog格式设置为row。这，也是现在不少公司使用的配置组合。
    务不需要可重复读的保证，这样考虑到读提交下操作数据的锁范围更小（没有间隙锁），这个选择是合理的
    
    然后，在备份期间，备份线程用的是可重复读，而业务线程用的是读提交。同时存在两种事务隔离级别，会不会有问题
    
   
