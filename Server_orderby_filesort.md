# filesort





# 全字段排序

## 原理



## 流程

1. 初始化 sort_buffer，确定放入 name、city、age 这三个字段；
2. 从索引 city 找到第一个满足 city='杭州’条件的主键 id，也就是图中的 ID_X；
3. 到主键 id 索引取出整行，取 name、city、age 三个字段的值，存入 sort_buffer 中；
4. 从索引 city 取下一个记录的主键 id；
5. 重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的
ID_Y；
6. 对 sort_buffer 中的数据按照字段 name 做快速排序；

图中“按 name 排序”这个动作，可能在内存中完成，也可能需要使用外部排序，这取决
于排序所需的内存和参数 sort_buffer_size。
sort_buffer_size，就是 MySQL 为排序开辟的内存（sort_buffer）的大小。如果要排序
的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放
不下，则不得不利用磁盘临时文件辅助排序



## 示例

SQL



查看



	来确定一个排序语句是否使用了临时文件







filesort
	 使用内存或者文件进行 慢
	 使用内存或者文件进行
	
	优缺点
	
	
	
	# FileSort
	
	排序缓存 
	  设置值
	排序算法
	  一次扫描  * 
	  两次扫描  旧的 
	  选择 一次 除非 blob text  数据过大
	
	# 排序算法
	
	所以filesort是否会使用磁盘取决于它操作的数据量大小。
	
	总结来说就是，filesort按排序方式来划分 分为两种：
	
	1.数据量小时，在内存中快排
	2.数据量大时，在内存中分块快排，再在磁盘上将各个块做归并
	
	数据量大的情况下涉及到磁盘io，所以效率会低一些。
	
	根据回表查询的次数，filesort又可以分为两种方式：
	
	1.回表读取两次数据(two-pass)：两次传输排序
	2.回表读取一次数据(single-pass)：单次传输排序
	
	
	
	## 全字段排序
	
	## rowId排序
	
	## 对比
	
	全字段排序是MySQL5.0以后
	
	
	
	
	
	# 内存排序
	
	
	# 使用临时表排序
	
	## 示例
	
	SQL
	
	EXPLAIN
  


