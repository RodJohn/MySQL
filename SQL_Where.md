
访问方法
单表查询
MySQL执行查询语句的方式称之为访问方法或者访问类型
查询的执行方式大致分为下边两种
使用全表扫描进行查询
这种执行方式很好理解，就是把表的每一行记录都扫一遍嘛，把符合搜索条件的记录加入到结果集就完了。

使用索引进行查询

如果查询语句中的搜索条件可以使用到某个索引，那直接使用索引来执行查询可能会加快查询执行的时间。使用索引来执行查询的方式五花八门，又可以细分为许多种类：

针对主键或唯一二级索引的等值查询

针对普通二级索引的等值查询

针对索引列的范围查询

直接扫描整个索引


# const

通过主键或者唯一二级索引列来定位一条记录的访问方法定义为：const
主键或者唯一二级索引那样最多只能匹配1条记录
回表


主键列或者唯一二级索引列和一个常数进行等值比较时才有效，如果主键或者唯一二级索引是由多个列构成的话，索引中的每一个列都需要与常数进行等值比较，



# ref


二级索引列与常数等值比较，采用二级索引来执行查询的访问方法称为：ref

回表

由于普通二级索引并不限制索引列值的唯一性，所以可能找到多条对应的记录
也就是说使用二级索引来执行查询的代价取决于等值匹配到的二级索引记录条数
如果匹配的记录较少，则回表的代价还是比较低的


# null

因为唯一二级索引列并不限制 NULL 值的数量，所以上述语句可能访问到多条记录

二级索引列值为NULL的情况

不论是普通的二级索引，还是唯一二级索引，它们的索引列对包含NULL值的数量并不限制，所以我们采用key IS NULL这种形式的搜索条件最多只能使用ref的访问方法，而不是const的访问方法。

# ref_or_null

有时候我们不仅想找出某个二级索引列的值等于某个常数的记录，还想把该列的值为NULL的记录也找出来，就像下边这个查询：

SELECT * FROM single_demo WHERE key1 = 'abc' OR key1 IS NULL;
当使用二级索引而不是全表扫描的方式执行该查询时，这种类型的查询使用的访问方法就称为ref_or_null，



# range

利用索引进行范围匹配的访问方法称之为：range

明确range访问方法使用的范围区间
其实对于B+树索引来说，只要索引列和常数使用=、<=>、IN、NOT IN、IS NULL、IS NOT NULL、>、<、>=、<=、BETWEEN、!=（不等于也可以写成<>）或者LIKE操作符连接起来，就可以产生一个所谓的区间。



SELECT * FROM single_table WHERE key2 IN (1438, 6328) OR (key2 >= 38 AND key2 <= 79);


# index

二级索引 的索引覆盖

由于二级索引记录比聚簇索记录小的多（聚簇索引记录要存储所有用户定义的列以及所谓的隐藏列，而二级索引记录只需要存放索引列和主键），而且这个过程也不用进行回表操作，所以直接遍历二级索引比直接遍历聚簇索引的成本要小很多，设计MySQL的大叔就把这种采用遍历二级索引记录的执行方式称之为：index


# all



最直接的查询执行方式就是我们已经提了无数遍的全表扫描，对于InnoDB表来说也就是直接扫描聚簇索引，

设计MySQL的大叔把这种使用全表扫描执行查询的方式称之为：all


# null


不论是普通的二级索引，还是唯一二级索引，它们的索引列对包含NULL值的数量并不限制，所以我们采用key IS NULL这种形式的搜索条件最多只能使用ref的访问方法，而不是const的访问方法。






