

# JOIN



连接查询的结果集中包含一个表中的每一条记录与另一个表中的每一条记录相互匹配的组合，

像这样的结果集就可以称之为笛卡尔积


表连接起来产生的笛卡尔积可能是非常巨大的



# 过滤



表连接起来产生的笛卡尔积可能是非常巨大的



搜索条件 关联条件



# 连接类型

INNER JOIN  OUTER JOIN 两种 （LEFT OUT JOIN  ，FULL JOIN 笛卡尔积 NATURAL JOIN）

半连接  

驱动表 可调整


简单嵌套循环

# 嵌套循环连接（Nested-Loop Join）

两层循环  循环匹配 遍历驱动表，选取被驱动表中的每一行   

如果驱动表的某一行不能在被驱动表中匹配到数据
内连接 丢弃不能匹配的驱动数据  
外链接 用null 表示 匹配数据

驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于对驱动表执行单表查询后的结果集中的记录条数的连接执行方式称之为嵌套循环连接（Nested-Loop Join），这是最简单，也是最笨拙的一种连接查询算法



步骤1：选取驱动表，使用与驱动表相关的过滤条件，选取代价最低的单表访问方法来执行对驱动表的单表查询。

步骤2：对上一步骤中查询驱动表得到的结果集中每一条记录，都分别到被驱动表中查找匹配的记录。


# 疑问 

left out join 和 循环条件的 问题  




# 使用索引加快连接速度

在嵌套循环中使用 查找被驱动表的数据时使用索引  把对驱动表的全表扫描变为 索引全扫描

# 基于块的嵌套循环连接（Block Nested-Loop Join）

# 块嵌套循环

使用连接缓冲  执行计划显示Using join buffer  

步骤
将驱动表符合规则的数据 存入 连接缓存中
用整个
如果  相当于只要遍历一次 被驱动表

相当于 连接 逆转了

当被驱动表中的数据非常多时，每次访问被驱动表，被驱动表的记录会被加载到内存中，在内存中的每一条记录只会和驱动表结果集的一条记录做匹配，之后就会被从内存中清除掉。然后再从驱动表结果集中拿出另一条记录，再一次把被驱动表的记录加载到内存中一遍，周而复始，驱动表结果集中有多少条记录，就得把被驱动表从磁盘上加载到内存中多少次。所以我们可不可以在把被驱动表的记录加载到内存的时候，一次性和多条驱动表中的记录做匹配，这样就可以大大减少重复从磁盘上加载被驱动表的代价了。



所以设计MySQL的大叔提出了一个join buffer的概念，

join buffer就是执行连接查询前申请的一块固定大小的内存，

先把若干条驱动表结果集中的记录装在这个join buffer中，

然后开始扫描被驱动表，每一条被驱动表的记录一次性和join buffer中的多条驱动表记录做匹配，

因为匹配的过程都是在内存中完成的，所以这样可以显著减少被驱动表的I/O代价。


最好的情况是join buffer足够大，能容纳驱动表结果集中的所有记录，这样只需要访问一次被驱动表就可以完成连接操作了。设计MySQL的大叔把这种加入了join buffer的嵌套循环连接算法称之为基于块的嵌套连接（Block Nested-Loop Join）算法。



另外需要注意的是，驱动表的记录并不是所有列都会被放到join buffer中，只有查询列表中的列和过滤条件中的列才会被放到join buffer中，所以再次提醒我们，最好不要把*作为查询列表，只需要把我们关心的列放到查询列表就好了，这样还可以在join buffer中放置更多的记录呢哈

# BKA MRR 

5.6

按照 主按键顺序 来取数值

# 块循环散列

MariaDB 才支持




