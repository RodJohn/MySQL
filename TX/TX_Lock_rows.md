



Record Locks：

仅仅把一条记录锁上，
官方的类型名称为：LOCK_REC_NOT_GAP


Gap Locks：


官方的类型名称为：LOCK_GAP，我们也可以简称为gap锁

给一条记录加了gap锁只是不允许其他事务往这条记录前边的间隙插入新记录
如图中为number值为8的记录加了gap锁，意味着不允许别的事务在number值为8的记录前边的间隙插入新记录，其实就是number列的值(3, 8)这个区间的新记录是不允许立即插入的。

这个gap锁的提出仅仅是为了防止插入幻影记录而提出的
但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些幻影记录加上正经记录锁。


Next-Key Locks：

官方的类型名称为：LOCK_ORDINARY，我们也可以简称为next-key锁。
有时候我们既想锁住某条记录，又想阻止其他事务在该记录前边的间隙插入新记录，
next-key锁的本质就是一个正经记录锁和一个gap锁的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的间隙

Insert Intention Locks：

官方的类型名称为：LOCK_INSERT_INTENTION，我们也可以称为插入意向锁。

表明有事务想在某个间隙中插入新记录，但是现在在等待。
我们说一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了所谓的gap锁（next-key锁也包含gap锁，后边就不强调了），
如果有的话，插入操作需要等待，直到拥有gap锁的那个事务提交。








# 两阶段锁

在InnoDB事务中，

行锁是在需要的时候才加上的，

但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。



如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。


