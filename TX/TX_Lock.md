
数据库锁设计的初衷是处理并发问题。


# 多粒度锁


级别

行级锁 表级锁 实例级锁

对一条记录加锁影响的也只是这条记录而已

对一个表加锁影响整个表中的记录


类型

。给表加的锁也可以分为共享锁（S锁）和独占锁（X锁）


例如

给表加S锁：
如果一个事务给表加了S锁，那么：
别的事务可以继续获得该表的S锁
别的事务可以继续获得该表中的某些记录的S锁
别的事务不可以继续获得该表的X锁
别的事务不可以继续获得该表中的某些记录的X锁

给表加X锁：
如果一个事务给表加了X锁（意味着该事务要独占这个表），那么：
别的事务不可以继续获得该表的S锁
别的事务不可以继续获得该表中的某些记录的S锁
别的事务不可以继续获得该表的X锁
别的事务不可以继续获得该表中的某些记录的X锁

意向锁（英文名：Intention Locks）的东东：
意向共享锁，英文名：Intention Shared Lock，简称IS锁。当事务准备在某条记录上加S锁时，需要先在表级别加一个IS锁。
意向独占锁，英文名：Intention Exclusive Lock，简称IX锁。当事务准备在某条记录上加X锁时，需要先在表级别加一个IX锁。

IS、IX锁是表级锁，它们的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁，以避免用遍历的方式来查看表中有没有上锁的记录，也就是说其实IS锁和IX锁是兼容的，IX锁和IX锁是兼容的。






# 数据修改

行锁  必须提交后释放

在innodb中，一个事物可以对一行数据进行多次修改，只有在


能不能在两个事务中交叉更新同一条记录呢？

哈哈，这不就是一个事务修改了另一个未提交事务修改过的数据，沦为了脏写了么？

InnoDB使用锁来保证不会有脏写情况的发生，也就是在第一个事务更新了某条记录后，就会给这条记录加锁，另一个事务再次更新时就需要等待第一个事务提交了，

把锁释放之后才可以继续更新。
