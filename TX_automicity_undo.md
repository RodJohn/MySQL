
# undo日志

    每条记录在更新的时候都会同时记录一条回滚操作。
    记录上的最新值，通过回滚操作，都可以得到前一个状态的值

#  INSERT


插入过程


    插入操作的结果就是这条记录被放到了一个数据页中。
    
    每当新插入记录时，
    首先判断PAGE_FREE指向的头节点代表的已删除记录占用的存储空间是否足够容纳这条新插入的记录，
    如果不可以容纳，就直接向页面中申请新的空间来存储这条记录
    
undolog
    
    如果希望回滚这个插入操作，那么把这条记录删除就好了，
    也就是说在写对应的undo日志时，主要是把这条记录的主键信息记上。
    
# DELETE

删除过程

    数据页中的正常记录会根据记录中的next_record属性组成一个单向链表，也就是记录链表
    被删除的记录也会根据记录中的next_record属性组成一个单向链表，也就是垃圾链表
    
    删除的过程需要经历两个阶段
    阶段一：仅仅将记录的delete_mask标识位设置为1
    在删除语句所在的事务提交之前，被删除的记录一直都处于这种所谓的中间状态
      
    阶段二：当该删除语句所在的事务提交之后，会有专门的线程后来真正的把记录删除掉。
    所谓真正的删除就是把该记录从正常记录链表中移除，并且加入到垃圾链表中，
    也叫做purge

undolog

    记录主键信息

    在对一条记录进行delete mark操作前，
    需要把该记录的旧的trx_id和roll_pointer隐藏列的值都给记到对应的undo日志中来
    这个链表就称之为版本链
    
    
# UPDATE


## 更新过程

在不更新主键的情况下


    就地更新（in-place update）
    更新记录时，对于被更新的每个列来说，如果更新后的列和更新前的列占用的存储空间都一样大，
    
    先删除掉旧记录，再插入新记录
    在不更新主键的情况下，如果有任何一个被更新的列更新前和更新后占用的存储空间大小不一致，
    那么就需要先把这条旧的记录从聚簇索引页面中删除掉，然后再根据更新后列的值创建一条新的记录插入到页面中。
    这里如果新创建的记录占用的存储空间大小不超过旧记录占用的空间，那么可以直接重用被加入到垃圾链表中的旧记录所占用的存储空间，
    否则的话需要在页面中新申请一段空间以供新记录使用，
    如果本页面内已经没有可用的空间的话，那就需要进行页面分裂操作，然后再插入新记录
    （频繁更新的表 也可能是随机IO了）


更新主键的情况

    在聚簇索引中，记录是按照主键值的大小连成了一个单向链表的
    如果我们更新了某条记录的主键值，意味着这条记录在聚簇索引中的位置将会发生改变
    将旧记录进行delete mark操作
    根据更新后各列的值创建一条新记录，并将其插入到聚簇索引中（需重新定位插入的位置）
    (相当于DELETE加INSERT)

## undolog

在不更新主键的情况下

    记录主键信息
    需要把该记录的旧的trx_id和roll_pointer隐藏列的值都给记到对应的undo日志中来
    记录更新前的数据
    
更新主键的情况
    
    其实就是一个DELETE的undolog+一个INSERT的undolog
  
  
  
# 分类
  
    1.insert undo log
    指在insert操作中产生的undo log，因为insert操作的记录只对事务本身可见。因此该undo log在事务提交后直接删除，不需要进行purge操作。
    
    2.update undo log
    记录的是对delete和update操作产生的undo log，该log需要提供mvcc机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行清除。
  

    



# undo页链

undo页链表

    undo日志被存放到undo页中
    不同类型的undo日志(insert/update)放在不同的undo页中  
    不同类型的undo页形成不同的undo链表
    每个事务单独分配相应的Undo页面链表
    （最多可能单独分配4个链表，临时表和物理表不通用）。


重用Undo页面

    但是这样也造成了一些问题，比如其实大部分事务执行过程中可能只修改了一条或几条记录，
    针对某个Undo页面链表只产生了非常少的undo日志，
    这些undo日志可能只占用一丢丢存储空间，每开启一个事务就新创建一个Undo页面链表


# 回滚段

    undo页链表都存放在回滚段中

回滚段数量决定最高事务数

    我们说一个事务执行过程中最多分配4个Undo页面链表，而一个回滚段里只有1024个undo slot，
    很显然undo slot的数量有点少啊。我们即使假设一个读写事务执行过程中只分配1个Undo页面链表，那1024个undo slot也只能支持1024个读写事务同时执行，
    
    
    话说在InnoDB的早期发展阶段的确只有一个回滚段，但是设计InnoDB的大叔后来意识到了这个问题，咋解决这问题呢？
    会议室不够，多盖几个会议室不就得了。所以设计InnoDB的大叔一口气定义了128个回滚段，也就相当于有了128 × 1024 = 131072个undo slot。
    假设一个读写事务执行过程中只分配1个Undo页面链表，那么就可以同时支持131072个读写事务并发执行（这么多事务在一台机器上并发执行，还真没见过呢～）。




