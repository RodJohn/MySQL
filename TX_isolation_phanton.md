
# 幻读

    幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。
    
    
    在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。
    
    
    上面session B的修改结果，被session A之后的select语句用“当前读”看到，不能称为幻读。幻读仅专指“新插入的行”。
    
    
    
# 问题

    首先是语义上的
    
 # 间隙锁
    
    行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。
    因此，为了解决幻读问题，InnoDB只好引入新的锁，也就是间隙锁(Gap Lock)。
    
        
    跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作
    
    间隙锁和行锁合称next-key lock，每个next-key lock是前开后闭区间。
    也就是说，我们的表t初始化以后，如果用select * from t for update要把整个表所有记录锁起来，就形成了7个next-key lock，
    分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]。
        

# 影响



示例


 
 
 
 # 解决
 
    分析的问题都是在可重复读隔离级别下的，间隙锁是在可重复读隔离级别下才会生效的。
    所以，你如果把隔离级别设置为读提交的话，就没有间隙锁了。
    但同时，你要解决可能出现的数据和日志不一致问题，需要把binlog格式设置为row。这，也是现在不少公司使用的配置组合。


    务不需要可重复读的保证，这样考虑到读提交下操作数据的锁范围更小（没有间隙锁），这个选择是合理的
    
    然后，在备份期间，备份线程用的是可重复读，而业务线程用的是读提交。同时存在两种事务隔离级别，会不会有问题
    
    
 
    