

# 索引


MySQL在进行GROUP BY操作的时候要想利用索引，
必须满足GROUP BY的字段必须同时存放于同一个索引中，且该索引是一个有序索引（如Hash索引就不能满足要求）。
而且，并不只是如此，是否能够利用索引来实现GROUP BY还与使用的聚合函数也有关系。

优化Group By最有效的办法是当可以直接使用索引来完全获取需要group的字段

# 紧凑索引

使用紧凑（Tight）索引扫描实现GROUP BY

紧凑索引扫描实现GROUP BY和松散索引扫描的区别主要在于他需要在扫描索引的时候，
读取所有满足条件的索引键，然后再根据读取的数据来完成GROUP BY操作得到相应结果。



示例

explain



# 松散索引

1. 使用松散（Loose）索引扫描实现GROUP BY

实际上就是当MySQL完全利用索引扫描来实现GROUP BY的时候，
并不需要扫描所有满足条件的索引键即可完成操作得出结果。

优化Group By最有效的办法是当可以直接使用索引来完全获取需要group的字段。
使用这个访问方法时，MySQL使用对关键字排序的索引的类型（比如BTREE索引）。
这使得索引中用于group的字段不必完全涵盖WHERE条件中索引对应的key。由于只包含索引中关键字的一部分，因此称为松散的索引扫描。


松散索引扫描，此类查询的EXPLAIN输出显示Extra列的Using index for group-by



为什么松散索引扫描的效率会很高？

因为在没有WHERE子句，也就是必须经过全索引扫描的时候，
松散索引扫描需要读取的键值数量与分组的组数量一样多，也就是说比实际存在的键值数目要少很多。
而在WHERE子句包含范围判断式或者等值表达式的时候，松散索引扫描查找满足范围条件的每个组的第1个关键字，并且再次读取尽可能最少数量的关键字。


explain


# 临时表

使用临时表实现 GROUP BY
MySQL Query Optimizer 发现仅仅通过索引扫描并不能直接得到 GROUP BY 的结果之后，他就不得不选择通过使用临时表然后再排序的方式来实现 GROUP BY了。
在这样示例中即是这样的情况。 
group_id 并不是一个常量条件，而是一个范围，而且 GROUP BY 字段为 user_id。
所以 MySQL 无法根据索引的顺序来帮助 GROUP BY 的实现，
只能先通过索引范围扫描得到需要的数据，然后将数据存入临时表，然后再进行排序和分组操作来完成 GROUP BY。

explain
SELECT group_id
FROM group_message
WHERE group_id between 1 and 4
GROUP BY user_id;



# 优化

对于上面三种MySQL处理GROUP BY的方式，我们可以针对性的得出如下两种优化思路：

1.尽可能让MySQL可以利用索引来完成GROUP BY操作，当然最好是松散索引扫描的方式最佳。在系统允许的情况下，我们可以通过调整索引或者调整Query这两种方式来达到目的；

2.当无法使用索引完成GROUP BY的时候，由于要使用到临时表且需要filesort，所以我们必须要有足够的sort_buffer_size来供MySQL排序的时候使用，而且尽量不要进行大结果集的GROUP BY操作，因为如果超出系统设置的临时表大小的时候会出现将临时表数据copy到磁盘上面再进行操作，这时候的排序分组操作性能将是成数量级的下降；

 

至于如何利用好这两种思路，还需要大家在自己的实际应用场景中不断的尝试并测试效果，最终才能得到较佳的方案。此外，在优化GROUP BY的时候还有一个小技巧可以让我们在有些无法利用到索引的情况下避免filesort操作，也就是在整个语句最后添加一个以null排序（ORDER BY null）的子句，大家可以尝试一下试试看会有什么效果。

 
 https://www.cnblogs.com/ggjucheng/archive/2012/11/18/2776449.html
 
