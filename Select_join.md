


Index Nested-Loop Join    N + N * log(扇出数)M
Block Nested-Loop Join    N + K * M 
Simple Nested-Loop Join   N + N * M  


# 
 
 


  
# 优化方案


索引
小表

临时表
业务端 操作
实际上，这个优化思路，我们可以自己实现在业务端

1. BKA 优化是 MySQL 已经内置支持的，建议你默认使用； 
2. BNL 算法效率低，建议你都尽量转成 BKA 算法。优化的方向就是给被驱动表的关联字 段加上索引； 
3. 基于临时表的改进方案，对于能够提前过滤出小数据的 join 语句来说，效果还是很好 的； 
4. MySQL 目前的版本还不支持 hash join，但你可以配合应用端自己模拟出来，理论上效 果要好于临时表的方案。





# JOIN



连接查询的结果集中包含一个表中的每一条记录与另一个表中的每一条记录相互匹配的组合，

像这样的结果集就可以称之为笛卡尔积


表连接起来产生的笛卡尔积可能是非常巨大的



# 过滤



表连接起来产生的笛卡尔积可能是非常巨大的



搜索条件 关联条件

WHERE子句中的过滤条件就是我们平时见的那种，不论是内连接还是外连接，凡是不符合WHERE子句中的过滤条件的记录都不会被加入最后的结果集。

ON子句中的过滤条件

对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用NULL值填充。

需要注意的是，这个ON子句是专门为外连接驱动表中的记录在被驱动表找不到匹配记录时应不应该把该记录加入结果集这个场景下提出的，所以如果把ON子句放到内连接中，MySQL会把它和WHERE子句一样对待，也就是说：内连接中的WHERE子句和ON子句是等价的。

在驱动表中的记录不符合ON子句中的连接条件时不会把该记录加入到最后的结果集


选取驱动表，使用与驱动表相关的过滤条件，选取代价最低的单表访问方法来执行对驱动表的单表查询。


？？
对于内连接来说，选取哪个表为驱动表都没关系，而外连接的驱动表是固定的，也就是说左（外）连接的驱动表就是左边的那个表，右（外）连接的驱动表就是右边的那个表




# 连接类型

INNER JOIN  OUTER JOIN 两种 （LEFT OUT JOIN  ，FULL JOIN 笛卡尔积 NATURAL JOIN）


对于内连接的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集，我们上边提到的连接都是所谓的内连接。

对于外连接的两个表，驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。

半连接  

驱动表 可调整


简单嵌套循环

# 嵌套循环连接（Nested-Loop Join）

两层循环  循环匹配 遍历驱动表，选取被驱动表中的每一行   

如果驱动表的某一行不能在被驱动表中匹配到数据
内连接 丢弃不能匹配的驱动数据  
外链接 用null 表示 匹配数据

驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于对驱动表执行单表查询后的结果集中的记录条数的连接执行方式称之为嵌套循环连接（Nested-Loop Join），这是最简单，也是最笨拙的一种连接查询算法



步骤1：选取驱动表，使用与驱动表相关的过滤条件，选取代价最低的单表访问方法来执行对驱动表的单表查询。

步骤2：对上一步骤中查询驱动表得到的结果集中每一条记录，都分别到被驱动表中查找匹配的记录。


# 疑问 

left out join 和 循环条件的 问题  


# 
SELECT * FROM t1, t2 WHERE t1.m1 > 1 AND t1.m1 = t2.m2 AND t2.n2 < 'd';
执行单表查询语句 确定第一个需要查询的表  
从驱动表产生的结果集中的每一条记录，分别需要到t2表中查找匹配的记录
这两个过滤条件，然后到t2表中执行单表查询

步骤1：选取驱动表，使用与驱动表相关的过滤条件，选取代价最低的单表访问方法来执行对驱动表的单表查询。

步骤2：对上一步骤中查询驱动表得到的结果集中每一条记录，都分别到被驱动表中查找匹配的记录。


图示





# 使用索引加快连接速度

在嵌套循环中使用 查找被驱动表的数据时使用索引  把对驱动表的全表扫描变为 索引全扫描


# 块嵌套循环

使用连接缓冲  执行计划显示Using join buffer  

步骤
将驱动表符合规则的数据 存入 连接缓存中
用整个
如果  相当于只要遍历一次 被驱动表

相当于 连接 逆转了

当被驱动表中的数据非常多时，每次访问被驱动表，被驱动表的记录会被加载到内存中，在内存中的每一条记录只会和驱动表结果集的一条记录做匹配，之后就会被从内存中清除掉。然后再从驱动表结果集中拿出另一条记录，再一次把被驱动表的记录加载到内存中一遍，周而复始，驱动表结果集中有多少条记录，就得把被驱动表从磁盘上加载到内存中多少次。所以我们可不可以在把被驱动表的记录加载到内存的时候，一次性和多条驱动表中的记录做匹配，这样就可以大大减少重复从磁盘上加载被驱动表的代价了。



所以设计MySQL的大叔提出了一个join buffer的概念，

join buffer就是执行连接查询前申请的一块固定大小的内存，

先把若干条驱动表结果集中的记录装在这个join buffer中，

然后开始扫描被驱动表，每一条被驱动表的记录一次性和join buffer中的多条驱动表记录做匹配，

因为匹配的过程都是在内存中完成的，所以这样可以显著减少被驱动表的I/O代价。


最好的情况是join buffer足够大，能容纳驱动表结果集中的所有记录，这样只需要访问一次被驱动表就可以完成连接操作了。设计MySQL的大叔把这种加入了join buffer的嵌套循环连接算法称之为基于块的嵌套连接（Block Nested-Loop Join）算法。



另外需要注意的是，驱动表的记录并不是所有列都会被放到join buffer中，只有查询列表中的列和过滤条件中的列才会被放到join buffer中，所以再次提醒我们，最好不要把*作为查询列表，只需要把我们关心的列放到查询列表就好了，这样还可以在join buffer中放置更多的记录呢哈







