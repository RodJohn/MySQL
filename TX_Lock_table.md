# 表级别的锁

MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。


# 表锁

表锁的语法是 lock tables … read/write。

与FTWRL类似，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。

需要注意，lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。


举个例子, 如果在某个线程A中执行lock tables t1 read, t2 write; 这个语句，则其他线程写t1、读写t2的语句都会被阻塞。

同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作。




# 元数据锁

表级的锁是MDL（metadata lock)。
在MySQL 5.5版本中引入了MDL，


MDL不需要显式使用，在访问一个表的时候会被自动加上。


当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。加索引



读锁是独占锁 

读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性


# 给一个小表加个字段，导致整个库挂了。



事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。

看看 示例 演示

比较理想的机制是，在alter table语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。

之后开发人员或者DBA再通过重试命令重复这个过程。



MariaDB已经合并了AliSQL的这个功能

