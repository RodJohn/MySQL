



# Simple Nested-Loop Join

原理

 使用嵌套循环来匹配数据

流程

1. 从驱动表中读入一行数据，并获取关联值
2. 遍历被驱动表，获得全部满足条件的被驱动行
3. 获取驱动行和被驱动行的笛卡尔积，作为结果集的一部分；
4. 重复执行步骤 1 到 3，直到驱动表的末尾循环结束。

示例

select * from t1 straight_join t2 on t1.a= t2.a 

1. 从表 t1 中读入一行数据 R； 
2. 从数据行 R 中，取出 a 字段到表 t2 里去查找； 
3. 取出表 t2 中满足条件的行，跟 R 组成一行，作为结果集的一部分； 
4. 重复执行步骤 1 到 3，直到表 t1 的末尾循环结束。

复杂度

假设驱动表的行数是 N，被驱动表的行数是 M。
执行过程就要扫描驱动表 N 行，扫描被驱动表 N * M 行
时间复杂度 N + N * M  


怎么选择驱动表
如果直接使用 join 语句，MySQL 优化器可能会选择表 t1 或 t2 作为驱动表
N 对扫描行数的影响更大，因此应该让小表来做驱动表

explain

# Index Nested-Loop Join

原理

  使用索引查找被驱动表中的匹配行
  
复杂度

假设驱动表的行数是 N，被驱动表的行数是 M。
执行过程就要扫描驱动表 N 行，
查询被驱动表 N 次, 每次的复杂度近似复杂度是以 扇出数 为底的 M 的对数,扇出一般都很大
时间复杂度 N + N * log(扇出数)M

explain

# Block Nested-Loop Join
原理

批量匹配被驱动表

流程

1. 把驱动表的数据读入线程内存 join_buffer 中
（如果放不下，那就分段放）
2. 遍历被驱动表的每一行，跟 join_buffer 中的数据做对比
3. 满足匹配条 件的，作为结果集的一部分返回


复杂度

假设驱动表的行数是 N，被驱动表的行数是 M。
分成K段放入内存中
执行过程就要扫描驱动表 N 行，扫描被驱动表 K * M 行
在内存中的判断次数是 M*N 次 内存操作，速度上会快很多
时间复杂度 N + K * M 

BNL 算法在大表 join 的时候性能就差多了，比较次数等于两个表参与 join 的行数 的乘积

join_buffer 的大小是由参数 join_buffer_size 设定的，默认值是 256k。
join_buffer_size 越大，一次可以放入 的行越多，分成的段数也就越少，对被驱动表的全表扫描次数就越少。



也就是说，BNL 算法对系统的影响主要包括三个方面：
1. 可能会多次扫描被驱动表，占用磁盘 IO 资源； 2. 判断 join 条件需要执行 M*N 次对比（M、N 分别是两张表的行数），如果是大表就会 占用非常多的 CPU 资源； 3. 可能会导致 Buffer Pool 的热数据被淘汰，影响内存命中率

BNL 转 BKA

explain 

# Batched Key Access


理解了 MRR 性能提升的原理，我们就能理解 MySQL 在 5.6 版本后开始引入的 Batched Key Acess(BKA) 算法了。
这个 BKA 算法，其实就是对 NLJ 算法的优化。

果要使用 BKA 优化算法的话，你需要在执行 SQL 语句之前，先设置
其中，前两个参数的作用是要启用 MRR。这么做的原因是，BKA 算法的优化要依赖于 MRR

一些情况下，我们可以直接在被驱动表上建索引，这时就可以直接转成 BKA 算法了



 explain 结果中，我们可以看到 Extra 字段多了 Using MRR，表示的是用上了 MRR 优化

# hash join

# 


Index Nested-Loop Join    N + N * log(扇出数)M
Block Nested-Loop Join    N + K * M 
Simple Nested-Loop Join   N + N * M  


# 
  
  
# 优化方案


索引
小表

临时表
业务端 操作
实际上，这个优化思路，我们可以自己实现在业务端

1. BKA 优化是 MySQL 已经内置支持的，建议你默认使用； 
2. BNL 算法效率低，建议你都尽量转成 BKA 算法。优化的方向就是给被驱动表的关联字 段加上索引； 
3. 基于临时表的改进方案，对于能够提前过滤出小数据的 join 语句来说，效果还是很好 的； 
4. MySQL 目前的版本还不支持 hash join，但你可以配合应用端自己模拟出来，理论上效 果要好于临时表的方案。






  

